# 递归

进一步剖析「递归」，先有「递」再有「归」，「递」的意思是将问题拆解成子问题来解决， 子问题再拆解成子子问题，...，直到被拆解的子问题无需再拆分成更细的子问题（即可以求解），「归」是说最小的子问题解决了，那么它的上一层子问题也就解决了，上一层的子问题解决了，上上层子问题自然也就解决了,....,

# 递归三大要素

## 第一要素： 明确这个函数想要干什么

```js
//算n的阶乘
function fn(int n){

}
```

## 第二要素：寻找递归结束条件

所谓的递归，就是会在函数内部代码中，调用函数本身。所以要找到递归的结束条件，不然的话 一直是自己调用自己，无底洞。

我们需要找出<mark>当参数为啥时，递归结束</mark>，之后直接把结果返回

例如上面的例子，当n=1时，f(1) = 1.要把第二要素加入代码里

```js
// 算 n 的阶乘(假设n>=1)
function fn(int n){
    if(n==1){
        return 1
    }
}
```

当 n = 2 时，那我们可以直接知道 f(n) 等于多少啊，那我可以把 n = 2 作为递归的结束条件吗？当然可以，只要你觉得参数是什么时，你能够直接知道函数的结果，那么你就可以把这个参数作为结束的条件，所以下面这段代码也是可以的。

```js
// 算 n 的阶乘(假设n>=2)
function fn(int n){
    if(n == 2){
        return 2
    }
}
```

注意我代码里面写的注释，假设 n >= 2，因为如果 n = 1时，会被漏掉，当 n <= 2时，f(n) = n，所以为了更加严谨，我们可以写成这样

```js
// 算 n 的阶乘(假设n不为0)
function fn(int n){
    if(n <= 2){
        return n;
    }
}
```

## 第三要素：找出函数的等价关系

我们需要不断的缩小参数的范围，缩小后，通过辅助变量或者操作，使得原函数 结果不变

f(n) 这个范围比较大，我们可以让 f(n) = n * f(n-1)。这样，范围就由 n 变成了 n-1 了，范围变小了，并且为了原函数f(n) 不变，我们需要让 f(n-1) 乘以 n。

说白了，就是要找到原函数的一个等价关系式，f(n) 的等价关系式为 n * f(n-1)，即

f(n) = n * f(n-1)。

那代码变成这样

```js
// 算 n 的阶乘(假设n不为0)
function fn(int n){
    if(n <= 2){
        return n
    }
    return f(n-1) * n
}

```

至此，递归三要素已经都写进代码里了，所以这个 f(n) 功能的内部代码我们已经写好了。

这就是递归最重要的三要素，每次做递归的时候，你就强迫自己试着去寻找这三个要素。

还是不懂？没关系，我再按照这个模式讲一些题。

---
<br></br>
### 案例1 斐波那契数列

斐波那契数列的是这样一个数列：1、1、3、5、8、13、21、34….，即第一项 f(1) = 1,第二项 f(2) = 1…..,第 n 项目为 f(n) = f(n-1) + f(n-2)。求第 n 项的值是多少。

1. 递归函数功能

```js
function fn (int n)
```

2. 找出递归结束条件

```js
function fn(int n){
    if(n<=2){
        return n
    }
}
```
3. 找出函数的等价关系式

题目已经把等价关系式给我们了，所以我们很容易就能够知道 f(n) = f(n-1) + f(n-2)。

```js
function fn(int n){
    if(n<=2){
        return n
    }
    return fn(n) = fn(n-1) + fn(n-2)
}
```

---
<br></br>
### 案例2 小青蛙跳台阶

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

1. 递归函数功能

```js
function fn(n){
    
}
```

2. 递归结束条件

求递归结束，直接把n压缩到很小就像，因为n越小，就可以越能看出f(n)的值。比如这个f(1) = 1

```js
function fn(n){
    if(n == 1){
        return 1
    }
}
```

3. 找出函数的等价关系

第一种跳法： 第一次跳一个台阶，第二次剩下(n-1)台阶没跳，剩下的n-1台阶跳法有f(n-1)种
   
第二种跳法：第一次跳两个台阶，剩下n-2没跳，剩下n-2台阶跳法有f(n-2)种

想不懂为什么是f(n-1)? 如果 f(n) 代表跳到 n 级台阶的跳法，那么n-1阶台阶就是f(n-1)

所以，小青蛙的全部跳法就是这两种跳法之和了，即 f(n) = f(n-1) + f(n-2)。至此，等价关系式就求出来了。于是写出代码：

```js
function fn(n){
    if(n == 1){
        return 1
    }
    return fn(n-1) + fn(n-2)
}
```

大家觉得上面的代码对不对？

答是不大对，当 n = 2 时，显然会有 f(2) = f(1) + f(0)。我们知道，f(0) = 0，按道理是递归结束，不用继续往下调用的，但我们上面的代码逻辑中，会继续调用 f(0) = f(-1) + f(-2)。这会导致无限调用，进入死循环。


递归结束条件是否够严谨问题,很多人使用递归结束条件不严谨，导致出现死循环，也就是说再第三步后，需要返回第二部，根据第三步函数调用，看看会不会出现漏掉的条件

```js
function fn(int n){
    if(n <= 2){
        return n
    }

    return f(n-1) + f(n-2)
}
```

---
<br></br>
### 案例3 反转单链表（leecode 206）

反转单链表。例如链表为：1->2->3->4。反转后为 4->3->2->1

题目思路： 
我们可以看成 
1(head) -> [2 -> 3 -> 4 -> null]

2(head)-> [ 3 -> 4 -> null]

3(head) -> [4 -> null]

4(head) -> null

1. 所以可以把一个大问题拆成两个子问题

2. 子问题求解方式和大问题一样

3. 存在最小子问题

所以可以使用递归思想

节点定义如下：
```js
class Node{
    int data
    Node next
}
```

1. 定义递归函数

```js
function reverseList(Node head){

}
```

2. 寻找结束条件
当链表为一个节点时，node.next = null,无需反转，
还有一个就是空表，无需反转

```js
function reverseList(Node head){
    if(head.next == null || head == null){
        return head
    }
}
```

1. 寻找等价关系
这个的等价关系不像 n 是个数值那样，比较容易寻找。但是我告诉你，它的等价条件中，一定是范围不断在缩小，对于链表来说，就是链表的节点个数不断在变小

---
[null <- 1 <- 2 <- 3 <- 4]
第四次归（同理）

---
1(head) -> [null <- 2 <- 3 <- 4]
第三次归（同理）

---
2(head)-> [  null <- 3 <- 4 ]

第二次归（完成步骤和第一步一样）

---
3(head) -> [4 -> null] 

第一次归 完成这一步就只需要，

head.next.next = head 

head.next = null

---
4(head) -> null （不需要执行任何动作，只有一个节点）



```js
function reverseList(Node head){
    if(head.next == null || head == null){
        return head
    }
    node newList =  reverseList(head.next) //head.next是一个子问题,递的过程

    return newList
}
```
把子问题放进去反转，然后要return反转后一部分的链表



接下来怎么办？只需要把2的next指向1 把1的next设为null即可

4->3->2->1->null


```js
function reverseList(Node head){
    if(head.next == null || head == null){
        return head
    }

    //递的过程
    node newList =  reverseList(head.next) 

    //归的过程
    head.next.next = head
    newList.next = null


    return newList
}
```







